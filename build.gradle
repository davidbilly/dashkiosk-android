buildDir = "$rootDir/build~"

buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:2.2.+'
        classpath 'com.android.tools.build:transform-api:1.5.+'
        classpath 'org.javassist:javassist:3.21.+'
        classpath 'commons-io:commons-io:2.4'
    }
}

repositories {
    maven {
        url 'https://download.01.org/crosswalk/releases/crosswalk/android/maven2'
    }
}

apply plugin: 'com.android.application'

dependencies {
    compile 'org.xwalk:xwalk_core_library:22.+'
}

android {
    sourceSets {
        main {
            manifest.srcFile 'AndroidManifest.xml'
            java.srcDirs = ['src']
            res.srcDirs = ['res']
        }
    }

    compileSdkVersion 21
    buildToolsVersion "25.0.0"

    lintOptions {
        disable 'MissingTvBanner', 'GradleDynamicVersion', 'GoogleAppIndexingWarning'
    }

    // Password signing for release
    def localPropertiesFile = rootProject.file('local.properties')
    if (localPropertiesFile.exists()) {
        def localProperties = new Properties()
        localProperties.load(new FileInputStream(localPropertiesFile))
        if (localProperties.getProperty("sign.store.file")) {
            signingConfigs {
                release {
                    storeFile file(localProperties.getProperty("sign.store.file"))
                    keyAlias localProperties.getProperty("sign.key.alias", "dashkiosk")
                    storePassword localProperties.getProperty("sign.store.password", "")
                    keyPassword localProperties.getProperty("sign.key.password", "")
                }
            }
            buildTypes {
                release {
                    signingConfig signingConfigs.release
                }
            }
        }
    }

}

// Prompting for passwords if needed. Use "./gradlew -q
// assembleRelease" to not get a mangled output.
gradle.taskGraph.whenReady { taskGraph ->
    if (android.hasProperty("signingConfigs") &&
        android.signingConfigs.hasProperty("release") &&
        taskGraph.hasTask(":assembleRelease")) {
        def console = System.console()
        def release = android.signingConfigs.release
        if (release.storePassword == "") {
            release.storePassword = new String(console.readPassword("> Keystore password: "))
        }
        if (release.keyPassword == "") {
            release.keyPassword = new String(console.readPassword("> Key password: "))
        }
        if (release.keyPassword == "") {
            release.keyPassword = release.storePassword;
        }
    }
}

// Create the wrapper
task wrapper(type: Wrapper) {
    gradleVersion = '2.14.1'
}

// Patch
import com.android.build.api.transform.Context
import com.android.build.api.transform.Format
import com.android.build.api.transform.QualifiedContent
import com.android.build.api.transform.Status
import com.android.build.api.transform.Transform
import com.android.build.api.transform.TransformException
import com.android.build.api.transform.TransformInput
import com.android.build.api.transform.TransformOutputProvider
import java.util.jar.JarEntry
import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import javassist.ClassPath
import javassist.ClassPool
import javassist.CtNewMethod
import org.apache.commons.io.FileUtils
import org.apache.commons.io.IOUtils
import org.gradle.api.logging.Logger
class PatchXWalkTransform extends Transform {
    Logger logger = null;

    public PatchXWalkTransform(Logger logger) {
        this.logger = logger
    }

    @Override
    String getName() {
        return "PatchXWalk"
    }

    @Override
    Set<QualifiedContent.ContentType> getInputTypes() {
        return Collections.singleton(QualifiedContent.DefaultContentType.CLASSES)
    }

    @Override
    Set<QualifiedContent.Scope> getScopes() {
        return Collections.singleton(QualifiedContent.Scope.EXTERNAL_LIBRARIES)
    }

    @Override
    boolean isIncremental() {
        return true
    }

    @Override
    void transform(Context context,
                   Collection<TransformInput> inputs,
                   Collection<TransformInput> referencedInputs,
                   TransformOutputProvider outputProvider,
                   boolean isIncremental) throws IOException, TransformException, InterruptedException {
        inputs.each {
            it.jarInputs.each {
                def jarName = it.name
                def src = it.getFile()
                def dest = outputProvider.getContentLocation(jarName, it.contentTypes, it.scopes, Format.JAR);
                def status = it.getStatus()
                if (status == Status.REMOVED) {
                    logger.info("Remove ${src}")
                    FileUtils.delete(dest)
                } else if (!isIncremental || status != Status.NOTCHANGED) {
                    if (src.toString() ==~ ".*/org.xwalk/xwalk_core.*/classes.jar") {
                        logger.info("Patching ${src}")

                        // Patch SslUtil.class
                        def pool = new ClassPool()
                        pool.insertClassPath("${src}")
                        def ctc = pool.get('org.xwalk.core.internal.SslUtil')
                        logger.debug("Replace SslUtil#shouldDenyRequest")
                        def ctm = ctc.getDeclaredMethod('shouldDenyRequest')
                        ctc.removeMethod(ctm)
                        ctc.addMethod(CtNewMethod.make("""
public static boolean shouldDenyRequest(int error) {
    return false;
}
""",
                                                       ctc))
                        logger.debug("Generate bytecode for SslUtil")
                        def sslUtilBytecode = ctc.toBytecode()

                        // Write back the JAR file
                        def input = new JarFile(src)
                        def output = new JarOutputStream(new FileOutputStream(dest))
                        input.entries().each {
                            if (!it.getName().equals("org/xwalk/core/internal/SslUtil.class")) {
                                logger.debug("Write back ${it.getName()} to JAR")
                                def s = input.getInputStream(it)
                                output.putNextEntry(new JarEntry(it.getName()))
                                IOUtils.copy(s, output)
                                s.close()
                            }
                        }
                        logger.debug("Write back modified class to JAR")
                        output.putNextEntry(new JarEntry("org/xwalk/core/internal/SslUtil.class"))
                        output.write(sslUtilBytecode)
                        output.close()
                    } else {
                        logger.info("Copy ${src}")
                        FileUtils.copyFile(src, dest)
                    }
                }
            }
        }
    }
}
android.registerTransform(new PatchXWalkTransform(logger))
